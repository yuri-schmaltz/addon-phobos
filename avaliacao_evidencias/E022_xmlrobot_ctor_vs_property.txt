0020:     SUPPORTED_VERSIONS = ["1.0"]
0021: 
0022:     _related_world_instance = None
0023:     _related_entity_instance = None
0024: 
0025:     def __init__(self, name=None, version=None, links: List[representation.Link] = None,
0026:                  joints: List[representation.Joint] = None,
0027:                  materials: List[representation.Material] = None,
0028:                  transmissions: List[representation.Transmission] = None,
0029:                  sensors=None, motors=None, plugins=None, root=None,
0030:                  is_human=False, urdf_version=None, xmlfile=None, _xmlfile=None):
0031:         self._related_robot_instance = self
0032:         super().__init__()
0033:         self.joints = []
0034:         self.links = []
0035:         self.parent_map = {}
0036:         self.child_map = {}
0037:         self.materials = []
0038:         self.transmissions = [] # [TODO v2.1.0] currently not fully supported
0039:         self.sensors = []
0040:         self.plugins = []  # Currently just a place holder
0041:         self.motors = []
0042:         self.xmlfile = xmlfile if xmlfile is not None else _xmlfile
0043: 
0044:         # Default export mesh format from phobos.defs.MESH_TYPES
0045:         self.mesh_format = "input_type"
0046: 
0047:         if name is None or len(name) == 0:
0048:             if self.xmlfile is not None:
0049:                 self.name, _ = os.path.splitext(_xmlfile)
0050:             else:
0051:                 self.name = None
0052:         else:
0053:             self.name = name
0054: 
0055:         self.version = version
0056:         self.urdf_version = "1.0" if urdf_version is None else urdf_version
0057: 
0058:         if joints is not None:
0059:             for joint in joints:
0060:                 self.add_aggregate("joint", joint)
0061:         if links is not None:
0062:             for link in links:
0063:                 self.add_aggregate("link", link)
0064: 
0065:         self.materials = materials if materials is not None else []
0066:         self.transmissions = transmissions if transmissions is not None else []
0067:         self.sensors = sensors if sensors is not None else []
0068:         self.motors = motors if motors is not None else []
0069:         if plugins is not None:
0070:             self.motors += [m for m in _plural(plugins) if isinstance(m, representation.Motor)]
0071: 
0072:         if is_human:
0073:             self.annotate_as_human()
0074: 
0075:         self.regenerate_tree_maps()
0076:         if self.links:
0077:             self.link_entities()
0078:             if root is not None:
0079:                 assert root in [str(l) for l in self.links], "root specified in xml is no link in the robot"
0080:                 assert root == str(self.get_root()), "root specified in xml is not root of the robot"
0081: 
0082:     def __str__(self):
0083:         return self.name
0084: 
0085:     def link_with_world(self, world, entity):
0086:         self._related_world_instance = world
0087:         self._related_entity_instance = entity
0088: 
0089:     def unlink_from_world(self):
0090:         self._related_world_instance = None
0091:         self._related_entity_instance = None
0092: 
0093:     def assert_validity(self):
0094:         assert self.get_root().origin is None or self.get_root().origin.is_zero()
0095: 
0096:     @property
0097:     def collisions(self):
0098:         return self.get_all_collisions()
0099: 
0100:     @property
0101:     def visuals(self):
0102:         return self.get_all_visuals()
0103: 
0104:     @property
0105:     def sensors_that_dont_belong_to_links_or_joints(self):
0106:         return [s for s in self.sensors if getattr(s, "link", None) is None and getattr(s, "joint", None) is None]
0107: 
0108:     @sensors_that_dont_belong_to_links_or_joints.setter
0109:     def sensors_that_dont_belong_to_links_or_joints(self, value):
0110:         value = _plural(value)
0111:         for s in value:
0112:             if not any([existing.name == s.name and existing.equivalent(s) for existing in self.sensors]):
0113:                 self.add_aggregate("sensor", s)
0114: 
